<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2022-10-07-ds复习-part-5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/07/2022-10-07-ds%E5%A4%8D%E4%B9%A0-part-5/" class="article-date">
  <time class="dt-published" datetime="2022-10-07T03:25:42.000Z" itemprop="datePublished">2022-10-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/07/2022-10-07-ds%E5%A4%8D%E4%B9%A0-part-5/">DS复习 Part 5</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="BST-amp-AVL"><a href="#BST-amp-AVL" class="headerlink" title="BST &amp; AVL"></a>BST &amp; AVL</h2><p>二分 (折半) 查找:</p>
<ul>
<li>仅适用于顺序查找 (因为需要随机访问), 仅适用于有序表.</li>
<li>平均查找长度 ASL 根据判定树可以很容易地计算出来. 二分查找判定树是一个平衡二叉树. 因为, 二分查找的默认计算方式是 <code>mid=(left+right)/2</code>, 即向下取整. 因此用 mid 分隔当前序列后, mid 左边的元素个数一定小于等于右边的元素个数, 相差为 0 或 1.</li>
<li>查找成功的 ASL 计算: $ASL&#x3D;\dfrac{1}{n}(1\times 2^0+2\times 2^1+\dots h\times 2^{h-1})&#x3D;\dfrac{1}{n}((h-1)\times 2^h+1)$. 这是因为, 第一层只有根结点, 长度是 1, 第 2 层有 2 个结点, 长度是 2, 按照满二叉树来考虑, 第 h 层就是 $2^{h-1}$ 个结点, 长度是 h. 假设原序列共有 n 个元素, 那么判定树中的成功查找结点共有 n 个, 树的高度就是 $h&#x3D;\lceil\log_2{(n+1)}\rceil&#x3D;\lfloor\log_2{(n+1)}\rfloor+1$. 为简便考虑, 我们假设 $h&#x3D;log_2{(n+1)}$, 则 $2^h&#x3D;n+1$. 因此:<br>$$<br>\begin{eqnarray}    \label{eq}<br>ASL&amp;&#x3D;&amp;\dfrac{1}{n}((log_2{(n+1)}-1)\times(n+1)+1) \nonumber    \<br>~&amp;&#x3D;&amp;\dfrac{1}{n}((n+1)\log_2{(n+1)}-n) \nonumber    \<br>~&amp;&#x3D;&amp;\dfrac{n+1}{n}\log_2{(n+1)}-1\approx\log_2{(n+1)}-1 \nonumber    \<br>\end{eqnarray}<br>$$</li>
<li>所以二分查找的时间复杂度是 $O(\log_2{n})$.</li>
</ul>
<p>二分查找的判定树是平衡二叉树, 是唯一的 (想一想平衡二叉树是怎么旋转出来的); 而二叉排序树会由于插入顺序的不同而生成不同的形态. 例如, 插入 24 和 12, 则 24 是根结点, 12 是其左孩子; 而插入 12 和 24, 则 12 是根结点, 24 是其右孩子.</p>
<p>既然二叉排序树有点鸡肋, 为什么还要用呢? 很简单, 如果二叉排序树没有成为一棵倾斜的单支树 (这种情况是 O(n)!), 那么它还是可以在不做任何旋转的情况下快速完成查找的. 毕竟左旋右旋 (相当于移动结点) 就挺麻烦的.</p>
<p>平衡二叉树 (Balanced Binary Tree, 但是我们熟知的 AVL 是发明者 Adelson-Velskii 以及 Landis 名字的缩写) 的出现: 为避免树的高度增长过快从而降低二叉排序树的性能, 就规定了任意结点的左右子树的高度差绝对值不超过 1. 这个高度差就称为此结点的“平衡因子”.</p>
<p>含有 n 个结点的平衡二叉树的最大深度为 $O(\log_2{n})$, 因此平衡二叉树的平均查找长度和时间复杂度也是 $O(\log_2{n})$.</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>为了保持 AVL 树的平衡性, 需要频繁地调整, 于是就在平衡标准上放宽条件, 有了红黑树.</p>
<p>红黑树的性质:</p>
<ol>
<li>每个结点要么是红的, 要么是黑的.</li>
<li>根结点是黑的.</li>
<li>每个叶结点 (NIL) 是黑的.</li>
<li>如果一个结点是红的, 那么它的两个孩子都是黑的 (这也说明它的父亲不可能是红的, 否则它的父亲就违背了“孩子是黑的”这条规则).</li>
<li>对于每个结点, 从该结点到其所有后代叶结点的简单路径上, 均包含相同数目的黑结点.</li>
</ol>
<p>黑高 bh: 从某结点 (不含该结点) 到一个叶结点的简单路径上的黑结点的数目.</p>
<p>叶结点称为<strong>外部结点</strong>, 其余的结点就是<strong>内部结点</strong>. 因为叶结点的存在本来就是为了保证内部结点的左右孩子非空.</p>
<p>结论 1: 从根结点到叶结点的最长路径不大于最短路径的 2 倍.</p>
<p><strong>证明</strong>: 因为从根结点到任意一个叶结点的路径上的黑结点的数目都相同, 设为 n, 那么最长路径就应该有 n-1 个红结点 (红黑相间, 且两端必是黑结点, 因为根结点和叶结点必须为黑结点), 因此最长路径的长度为 2n-1, 最短路径的长度为 n, 于是最长路径不大于最短路径的 2 倍.</p>
<p>结论 2: 有 n 个内部结点的红黑树的高度 $h\leq O(\log_2{(n+1)})$.</p>
<p><strong>证明</strong>:</p>
<p>设 bh(x) 表示结点 x 的黑高, 那么根结点 t 的黑高就是 bh(t).</p>
<p>根据红黑树的性质可知红色节点不可相邻, 但是并没有对黑色节点进行要求. 因此所有的黑色节点可以挨在一起, 一棵红黑树可以全部都是黑色节点. 那么我们就假设<strong>一棵只有黑色节点的红黑树</strong>, 其树高就是 bh(t). <strong>这一定是一棵高为 bh(t) 的满二叉树, 因为从根结点到任意叶结点都有路径, 路径上的黑结点数都相等, 而且路径上还全都是黑结点</strong>. 注意, 原本的 bh(t) 是不包含根结点、但是包含叶结点的, 而叶结点是外部结点, 我们要求的却是内部结点. 这其实是等价的, 相当于整体向上挪了一个结点, 毕竟根结点和叶结点都是黑色的. 于是, 总的内部结点数就是 $n&#x3D;2^{bh(t)}-1$.</p>
<p>刚才考虑的是全都是黑结点的特殊情况. 如果还要插入红结点, 那么内部结点数一定大于刚才的值. 因此, 总的内部结点数应该满足 $n\geq 2^{bh(t)}-1$.</p>
<p>现在回到一般情况. 设 h 是树高, 那么一定有 $bh(t)\geq\dfrac{h}{2}$. 于是, 有 $n\geq 2^{bh(t)}-1\geq 2^{\frac{h}{2}}-1$.</p>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>叶结点只是起到辅助作用, 属于查找不成功的「失败结点」, 而所有插入的结点都属于内部结点, 是查找成功的「成功结点」, 因此如果不加上叶结点的话, 内部结点构成的叶结点也可以是红色的.</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>不等式:</p>
<ul>
<li>n 是关键字个数, m 是阶数, 则 $\lceil\dfrac{m}{2}\rceil-1\leq n\leq m-1$.</li>
<li>h 是 B 树高度, 则 h 满足不等式: $\log_m{(n+1)}\leq h\leq\log_{\lceil m&#x2F;2\rceil}{(\dfrac{n+1}{2}+1)}$.</li>
</ul>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>新元素一定是插入到底层的终端结点中, 因为这样能够保证到最后所有的失败结点都在最底层. 如果插入后导致某些结点的关键字个数超过了 m-1, 那么就要进行分裂.</p>
<p>分裂的方法是: 从中间位置 $\lceil\dfrac{m}{2}\rceil$ 处将结点的关键字分裂成左中右三个部分 (中间部分就只有一个关键字, 即 $\lceil\dfrac{m}{2}\rceil$ 处的元素). 中间的关键字上升到父结点中. 如果父结点已经满了, 那么也要继续分裂, 直到根结点. 如果根结点也满了, 就新建一个根结点, 再将原根结点分裂成两部分.</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>如果要删除的关键字在终端结点, 则直接删除, 如果删除后导致结点内关键字个数小于 $\lceil\dfrac{m}{2}\rceil-1$, 就要进行合并或者借位.</li>
<li>如果要删除的关键字在非终端结点, 那么就要先找到它的直接前驱 (左子树最右下) 或直接后继 (右子树最左下), 用它替换要删除的关键字, 这样就转换成了删除终端结点的情况.</li>
</ul>
<p>因此, 下面着重探讨终端结点的删除.</p>
<p>当删除后导致结点内关键字个数小于 $\lceil\dfrac{m}{2}\rceil-1$ 时:</p>
<ul>
<li>能够找兄弟借:<ul>
<li>当右兄弟够借时 (意思是说, 取出右兄弟的最小关键字后, 右兄弟内关键字个数没有低于 $\lceil\dfrac{m}{2}\rceil-1$), 就用当前结点的后继、后继的后继填补空缺. 其中, 当前结点的后继就是当前结点的父结点中刚好大于它的那个关键字, 当前结点的后继的后继就是右兄弟的最小关键字.</li>
<li>如果右兄弟不够但左兄弟够, 就借前驱、前驱的前驱.</li>
</ul>
</li>
<li>兄弟都不够借, 则合并.<blockquote>
<p>正因为不够借, 所以其兄弟结点一定刚好有 $\lceil\dfrac{m}{2}\rceil-1$ 个关键字, 而当前结点的关键字个数 $n_{cur}\le\lceil\dfrac{m}{2}\rceil-1\leq\lceil\dfrac{m}{2}\rceil-2$. 再参照下面的合并方法可知, 合并后结点内关键字个数应该 $\leq(\lceil\dfrac{m}{2}\rceil-2)+1+(\lceil\dfrac{m}{2}\rceil-1)\leq m-1$. 这就证明了合并的结点是满足条件的.</p>
</blockquote>
<ul>
<li>例如, 可以合并当前结点和其右兄弟. 合并方法是: 将当前结点的后继从父结点中移下来, 然后把右兄弟的所有关键字接在后面, 三者共同构成一个结点.</li>
<li>但是这样可能会让父结点关键字个数小于 $\lceil\dfrac{m}{2}\rceil-1$, 所以还要继续合并 (兄弟不够借的情况下) 或借位 (兄弟够借). 如果最后合并到根结点关键字个数为 0 了 (这也说明, 根结点原来只有 1 个关键字, 而合并操作是合并了根结点仅有的两个子结点), 就删除根结点, 让合并后的结点 (原根结点的左子结点+根结点唯一的关键字+原根结点的右子结点) 成为新的根结点.</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/07/2022-10-07-ds%E5%A4%8D%E4%B9%A0-part-5/" data-id="clcljm1k300bu4osb28i74omh" data-title="DS复习 Part 5" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/" rel="tag">notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-10-05-ds复习-part-4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/05/2022-10-05-ds%E5%A4%8D%E4%B9%A0-part-4/" class="article-date">
  <time class="dt-published" datetime="2022-10-05T00:56:02.000Z" itemprop="datePublished">2022-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/05/2022-10-05-ds%E5%A4%8D%E4%B9%A0-part-4/">DS复习 Part 4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>连通分量: 无向图的极大连通子图.</p>
<p>生成树: 连通分量的极小连通子图.</p>
<p>最小生成树 (Minimum Spanning Tree, MST): 无向连通图的极小连通子图.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/05/2022-10-05-ds%E5%A4%8D%E4%B9%A0-part-4/" data-id="clcljm1k200br4osbhgcah5yz" data-title="DS复习 Part 4" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/" rel="tag">notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-10-04-ds复习-part-3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/04/2022-10-04-ds%E5%A4%8D%E4%B9%A0-part-3/" class="article-date">
  <time class="dt-published" datetime="2022-10-04T00:28:27.000Z" itemprop="datePublished">2022-10-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/04/2022-10-04-ds%E5%A4%8D%E4%B9%A0-part-3/">DS复习 Part 3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="树的常见结论"><a href="#树的常见结论" class="headerlink" title="树的常见结论"></a>树的常见结论</h1><p>在含有 n 个结点的二叉链表中, 含有 n+1 个空指针域.</p>
<p><strong>证明</strong>:</p>
<ul>
<li>方法 1: n 个结点有 2n 个指针, 而 n 个结点有 n-1 条边, 即有 n-1 个非根结点, 每个非根结点对应其父结点的一个指针域, 所以有 n-1 个非空指针域 (只有根结点没有指向它的指针, 因为没有父结点), 因此空指针域数量为 2n-(n-1)&#x3D;n+1.</li>
<li>方法 2: 每个叶结点有两个空指针, 每个度为 1 的结点有 1 个空指针, 因此空指针总数为 $2n_0+n_1$. 而 $n_0&#x3D;n_2+1$, 因此空指针共有 $2n_0+n_1&#x3D;n_0+n_0+n_1&#x3D;n_0+n_1+(n_2+1)&#x3D;n+1$.</li>
</ul>
<p>后序遍历的非递归算法… 居然可以应用于这么多场景:</p>
<ul>
<li>代码参考我的另一篇<a target="_blank" rel="noopener" href="https://ssc.moe/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95/#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">博客</a>.</li>
<li>根据代码可以很容易地看出, 栈中始终存放着 p 结点的所有祖先, 因此栈中所有结点就构成了从根结点到 p 结点的一条路径.</li>
<li>可以应用于: 求根结点到某结点到路径, 求两个结点的最近公共祖先 (LCA).</li>
</ul>
<h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><h2 id="线索二叉树的定义"><a href="#线索二叉树的定义" class="headerlink" title="线索二叉树的定义"></a>线索二叉树的定义</h2><p>若将二叉树中的空指针域改为指向其在某种遍历次序下的前驱和后继结点的指针, 则称为线索二叉树.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    ThreadNode *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>ltag&#x3D;0 表示 lchild 指向左孩子, ltag&#x3D;1 表示 lchild 指向前驱结点.</li>
<li>rtag&#x3D;0 表示 rchild 指向右孩子, rtag&#x3D;1 表示 rchild 指向后继结点.</li>
</ul>
<h2 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h2><h3 id="中序线索二叉树的遍历"><a href="#中序线索二叉树的遍历" class="headerlink" title="中序线索二叉树的遍历"></a>中序线索二叉树的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span> </span>&#123;</span><br><span class="line">    ThreadNode *p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;rtag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">            cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先序线索二叉树的遍历"><a href="#先序线索二叉树的遍历" class="headerlink" title="先序线索二叉树的遍历"></a>先序线索二叉树的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(ThreadNode *T)</span> </span>&#123;</span><br><span class="line">    ThreadNode *p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序线索二叉树的遍历"><a href="#后序线索二叉树的遍历" class="headerlink" title="后序线索二叉树的遍历"></a>后序线索二叉树的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(ThreadNode *T)</span> </span>&#123;</span><br><span class="line">    ThreadNode *p = T;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;rtag == <span class="number">1</span> &amp;&amp; p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadNode *p, ThreadNode *&amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;lchild, pre);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><p>三种表示法: 双亲表示法, 孩子表示法, 孩子兄弟表示法.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/04/2022-10-04-ds%E5%A4%8D%E4%B9%A0-part-3/" data-id="clcljm1k100bm4osbckqecbno" data-title="DS复习 Part 3" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/" rel="tag">notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-10-03-ds复习-part-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/03/2022-10-03-ds%E5%A4%8D%E4%B9%A0-part-2/" class="article-date">
  <time class="dt-published" datetime="2022-10-03T02:33:48.000Z" itemprop="datePublished">2022-10-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/03/2022-10-03-ds%E5%A4%8D%E4%B9%A0-part-2/">DS复习 Part 2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>操作受限的线性表 (正因为是线性表所以肯定就有“顺序”和“链式”这两种存储方式). 只能在一端进行操作. LIFO.</p>
<p>数学性质: <a target="_blank" rel="noopener" href="https://ssc.moe/posts/catalan-number-%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/">Catalan 数</a>. n 个不同元素进栈, 出栈元素的不同排列的个数为 $\dfrac{1}{n+1}C_{2n}^n$.</p>
<p>答题时可以直接“调用”的函数:</p>
<ul>
<li><code>void InitStack(&amp;S)</code></li>
<li><code>bool StackEmpty(S)</code></li>
<li><code>bool Push(&amp;S, x)</code></li>
<li><code>bool Pop(&amp;S, &amp;x)</code></li>
<li><code>bool GetTop(S, &amp;x)</code></li>
<li><code>void DestroyStack(&amp;S)</code></li>
</ul>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>数组存放, 用 <code>int top</code> 指示栈顶下标.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>

<p><code>S.top</code> 处是存储元素的. 数组从下标 0 开始存储.</p>
<ul>
<li><code>S.top = -1</code> 时为空栈.</li>
<li><code>S.top = MAXSIZE - 1</code> 时为满栈.</li>
<li>栈长: <code>S.top + 1</code>.</li>
<li>初始: <code>S.top = -1</code>.</li>
<li>入栈: <code>S.data[++S.top] = x</code>.</li>
<li>出栈: <code>x = S.data[S.top--]</code>.</li>
</ul>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>利用了栈底位置相对不变的特点. 两个栈共享一个数组, 栈底设在数组两端, 栈顶向中间增长.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top1;</span><br><span class="line">    <span class="type">int</span> top2;</span><br><span class="line">&#125; ShStack;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>top1 = -1</code> 时栈 1 为空栈.</li>
<li><code>top2 = MAXSIZE</code> 时栈 2 为空栈.</li>
<li><code>top1 + 1 = top2</code> 时为满栈.</li>
<li>入栈: <code>S.data[++S.top1] = x</code> 或 <code>S.data[--S.top2] = x</code>.</li>
<li>出栈: <code>x = S.data[S.top1--]</code> 或 <code>x = S.data[S.top2++]</code>.</li>
</ul>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p><code>Lhead</code> 指向栈顶元素.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    LinkNode *top;</span><br><span class="line">    <span class="comment">// int count;</span></span><br><span class="line">&#125; LinkStack;</span><br></pre></td></tr></table></figure>

<h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>采用非递归方式实现递归程序, 不一定非要用栈, 也可用循环, 如斐波那契数列.</p>
<p>栈中元素一定保持其输入顺序. 因此出栈时只可能是输入顺序的逆序.</p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>操作受限的线性表. 只能在两端进行操作. FIFO.</p>
<p>队头: <code>front</code>, 允许删除. 队尾: <code>rear</code>, 允许插入.</p>
<p>答题时可以直接“调用”的函数:</p>
<ul>
<li><code>void InitQueue(&amp;Q)</code></li>
<li><code>bool QueueEmpty(Q)</code></li>
<li><code>bool EnQueue(&amp;Q, x)</code></li>
<li><code>bool DeQueue(&amp;Q, &amp;x)</code></li>
<li><code>bool GetHead(Q, &amp;x)</code></li>
</ul>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><p>数组存放.</p>
<p><code>front</code> 指向队头元素, <code>rear</code> 指向队尾元素的下一个位置.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始时: <code>Q.front = Q.rear = 0</code>.</li>
<li>判空: <code>Q.front == Q.rear</code>.</li>
<li>插入: <code>Q.data[Q.rear++] = x;</code>.</li>
<li>删除: <code>x = Q.data[Q.front++];</code>.</li>
</ul>
<p>存在「假溢出」, 也就是说数组中明明有位置存储, 却因 <code>front</code> 指针移动到数组末尾而导致无法继续插入.</p>
<p>改进: 循环队列.</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><ul>
<li>初始时: <code>Q.front = Q.rear = 0</code>.</li>
<li>插入: <code>Q.data[Q.rear] = x; Q.rear = (Q.rear + 1) % MAXSIZE</code>.</li>
<li>删除: <code>x = Q.data[Q.front]; Q.front = (Q.front + 1) % MAXSIZE</code>.</li>
<li>元素个数: <code>(Q.rear - Q.front + MAXSIZE) % MAXSIZE</code>.</li>
</ul>
<p>三种情况:</p>
<ol>
<li>牺牲一个存储单元来区分队空和队满.<ul>
<li>队满: <code>(Q.rear + 1) % MAXSIZE == Q.front</code>.</li>
<li>队空: <code>Q.front == Q.rear</code>.</li>
<li>元素个数: <code>(Q.rear - Q.front + MAXSIZE) % MAXSIZE</code>.</li>
</ul>
</li>
<li>类型中增加一个 <code>Q.size</code> 记录元素个数, 用来区分队空和队满.<ul>
<li>队满: <code>Q.size == MAXSIZE</code>.</li>
<li>队空: <code>Q.size == 0</code>.</li>
<li>元素个数: <code>Q.size</code>.</li>
</ul>
</li>
<li>类型中增加一个 <code>Q.tag</code> 记录队列状态, 用来区分队空和队满.<ul>
<li>每次 <code>EnQueue</code> 成功后令 <code>Q.tag = 1</code>, <code>DeQueue</code> 成功后令 <code>Q.tag = 0</code>.</li>
<li>以 <code>DeQueue</code> 为例, 先令 <code>Q.tag = 0</code>, 然后执行 <code>Q.front = (Q.front + 1) % MAXSIZE</code>. 此时调用 <code>QueueEmpty(Q)</code> 进行判空: 如果 <code>Q.front == Q.rear &amp;&amp; Q.tag = 0</code>, 则队列为空. 同理, 如果 <code>Q.front == Q.rear &amp;&amp; Q.tag = 1</code>, 则队列为满.</li>
<li>因此这里的 <code>tag</code> 实际上是表示“上一次执行”的是插入还是删除操作. 如果是执行过一次插入操作后导致的 <code>Q.front == Q.rear</code>, 则队列为满; 如果是执行过一次删除操作后导致的 <code>Q.front == Q.rear</code>, 则队列为空. 因此每调用一次 <code>EnQueue</code> 或 <code>DeQueue</code>, 都要更新 <code>tag</code>.</li>
</ul>
</li>
</ol>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>允许在两端进行插入和删除操作 (出队和入队) 的队列. 队列的两端分别称为<em>前端</em>和<em>后端</em>.</p>
<p>逻辑结构是线性结构.</p>
<p>后端插入的可以从前端删除, 也可以从后端删除.</p>
<p>双端队列也是操作受限的线性表: 只允许两端插入、两端删除.</p>
<p>栈和队列都是双端队列的退化. 因此双端队列可以实现栈和队列的功能.</p>
<p>双端队列也有两个变种: (至于是哪一端其实不重要, 因为是等价的)</p>
<ul>
<li>输入受限的双端队列: 一端插入、两端删除.</li>
<li>输出受限的双端队列: 两端插入、一端删除.</li>
</ul>
<p>如果输入没有受限, 则双端队列中的元素不需要按照输入顺序排列.</p>
<p>如果输出没有受限, 则双端队列中的元素不需要按照输入顺序输出.</p>
<h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>链表存放.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    LinkNode *front;</span><br><span class="line">    LinkNode *rear;</span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure>

<h1 id="Stack-和-Queue-的应用"><a href="#Stack-和-Queue-的应用" class="headerlink" title="Stack 和 Queue 的应用"></a>Stack 和 Queue 的应用</h1><p>Stack:</p>
<ul>
<li>括号匹配</li>
<li>表达式求值: 中缀表达式转后缀表达式, 后缀表达式求值<ul>
<li>中缀表达式就是 <code>A+B*(C-D)-E/F</code>, 写成表达式树后进行后序遍历, 就得到了后缀表达式 <code>ABCD-*+EF/-</code>.</li>
<li>给出后缀表达式, 可以用栈来计算表达式的值.</li>
<li>算法: 顺序扫描后序表达式的每一项, 如果是操作数就入栈, 如果是操作符就从栈中弹出两个操作数, 进行运算, 然后将结果入栈. 最后栈中只剩下一个元素, 就是表达式的值.</li>
</ul>
</li>
<li>递归</li>
</ul>
<p>Queue:</p>
<ul>
<li>层次遍历</li>
<li>计算机系统:<ul>
<li>缓冲区</li>
<li>竞争资源的使用队列</li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>术语: 下标、维界 (下标的取值范围).</p>
<h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><ul>
<li>特殊矩阵: 有大量的零元素或相同非零元素的矩阵. 如对称矩阵、上 (下) 三角矩阵、对角矩阵.</li>
<li>压缩存储: 多个值相同的元素只存储一次.</li>
</ul>
<h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p><code>a[n*n]</code> 的对称矩阵: 只存放半个三角形. 假设将下三角区 (a11,a21,a22,a31,a32,a33,…) 存放在一维数组 <code>b[n(n+1)/2]</code> 中, 则 <code>a[i][j]</code> 在 <code>b</code> 中的位置是 <code>b[i*(i-1)/2+j]</code>.</p>
<blockquote>
<p><code>i&gt;j</code> 属于下三角区, <code>i=j</code> 属于主对角线, <code>i&lt;j</code> 属于上三角区.</p>
</blockquote>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>三角矩阵是这样的 (以下三角矩阵为例):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a[n][n]=&#123;</span><br><span class="line">    a11,a12,a13,...,a1n,</span><br><span class="line">    c,  a22,a23,...,a2n,</span><br><span class="line">    c,  c,  a33,...,a3n,</span><br><span class="line">    ...,</span><br><span class="line">    c,  c,  c,  ...,ann</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的 c 是常数, 不一定是 0, 和线性代数里的定义不太一样.<br>{: .prompt-warning}</p>
</blockquote>
<p><code>a[n*n]</code> 的上三角矩阵: 存放在一维数组 <code>b[n(n+1)/2+1]</code> 中, <code>a[i][j], i&gt;=j</code> 在 <code>b</code> 中的位置是 <code>b[j*(j-1)/2+i]</code>, <code>a[i][j], i&lt;j</code> 在 <code>b</code> 中的位置是 <code>b[n*(n+1)/2]</code>.</p>
<h3 id="三对角矩阵"><a href="#三对角矩阵" class="headerlink" title="三对角矩阵"></a>三对角矩阵</h3><p>也称为带状矩阵.</p>
<p>三对角矩阵是这样的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>][<span class="number">1</span>], a[<span class="number">1</span>][<span class="number">2</span>], <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">0</span>,</span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>], a[<span class="number">2</span>][<span class="number">2</span>], a[<span class="number">2</span>][<span class="number">3</span>], <span class="number">0</span>, ..., <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, a[<span class="number">3</span>][<span class="number">2</span>], a[<span class="number">3</span>][<span class="number">3</span>], a[<span class="number">3</span>][<span class="number">4</span>], ..., <span class="number">0</span>,</span><br><span class="line">...,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, ..., a[n<span class="number">-1</span>][n<span class="number">-2</span>], a[n<span class="number">-1</span>][n<span class="number">-1</span>], a[n<span class="number">-1</span>][n],</span><br><span class="line"><span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  ...,a[n][n<span class="number">-1</span>],a[n][n]</span><br></pre></td></tr></table></figure>

<p>可看作是有三条对角线.</p>
<p>存储方式: 以行优先存储.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>][<span class="number">1</span>], a[<span class="number">1</span>][<span class="number">2</span>], a[<span class="number">2</span>][<span class="number">1</span>], a[<span class="number">2</span>][<span class="number">2</span>], a[<span class="number">2</span>][<span class="number">3</span>], a[<span class="number">3</span>][<span class="number">2</span>], a[<span class="number">3</span>][<span class="number">3</span>], a[<span class="number">3</span>][<span class="number">4</span>], ..., a[n<span class="number">-1</span>][n<span class="number">-2</span>], a[n<span class="number">-1</span>][n<span class="number">-1</span>], a[n<span class="number">-1</span>][n], a[n][n<span class="number">-1</span>], a[n][n]</span><br></pre></td></tr></table></figure>

<p><code>a[i][j]</code> 存储于 <code>b[2i+j-3]</code>.</p>
<p><code>b[k]</code> 对应的 <code>a[i][j]</code> 是 $i&#x3D;\lfloor\dfrac{k+1}{3}+1\rfloor,j&#x3D;k-2i+3$.</p>
<p>推导: 对于 <code>a[i][j]</code>, 前面有 i-1 行, 其中第 1 行有 2 个元素, 第 2 到 i-1 行有 3 个元素, 总共有 <code>2+3(i-2)=3i-4</code> 个元素; 在第 i 行, 它的前面有 i-2 个 0, 它自己位于第 j 个位置, 因此是第 i 行的第 <code>j-(i-2)</code> 个非零元素. 于是, <code>a[i][j]</code> 在 <code>b</code> 中是第 <code>3i-4+j-(i-2)=2i+j-2</code> 个元素. 如果 <code>b</code> 从 0 开始存储, 则位于下标 <code>2i+j-3</code> 处.</p>
<p>逆推也很简单: 已知 k, 那么就是 <code>b</code> 中的第 k+1 个元素. 由于除了第一行以外全都是 3 个元素, 只有第一行是 2 个, 所以暂时先从第 i 行移动一个元素补到第一行, 因此 <code>i-1=(k+1)/3</code>. 这里的除法按照 C++ 标准默认向下取整了, 也可以写得规范一些. i 求出来了, 再通过 <code>k=2i+j-3</code> 就可以求出 j 了.</p>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>稀疏矩阵是指矩阵中大部分元素都是 0 的矩阵.</p>
<p>用三元组 (行, 列, 值) 存储.</p>
<p>十字链表法: 用两个链表存储, 一个链表存储行, 一个链表存储列.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/03/2022-10-03-ds%E5%A4%8D%E4%B9%A0-part-2/" data-id="clcljm1k000bj4osb8ulubsox" data-title="DS复习 Part 2" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/" rel="tag">notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-10-01-ds复习-part-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/01/2022-10-01-ds%E5%A4%8D%E4%B9%A0-part-1/" class="article-date">
  <time class="dt-published" datetime="2022-10-01T01:52:55.000Z" itemprop="datePublished">2022-10-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/01/2022-10-01-ds%E5%A4%8D%E4%B9%A0-part-1/">DS复习 Part 1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>考研复习进入了白热化阶段. 博客好久没更了. 代码好久没写了. fo 和 ⭐️ 都快要掉没了.</p>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据元素: 数据的基本单位</p>
<p>数据项: 构成数据元素的不可分割的最小单位</p>
<blockquote>
<p>一个数据元素可以由若干个数据项组成</p>
</blockquote>
<p>数据对象: 性质相同的数据元素的集合, 是数据的子集</p>
<p>数据类型: 一个值的集合和定义在此集合上的一组操作的总称. 包括: 原子类型, 结构类型, 抽象数据类型 (ADT)</p>
<p>数据结构: 相互之间存在一种或多种特定<strong>关系</strong>的<strong>数据元素</strong>的集合. 结构就是数据元素之间的关系. 由三个方面决定:</p>
<ul>
<li>逻辑结构: 集合, 线性, 树形, 图状或网状</li>
<li>存储结构: 顺序, 链式, 索引, 散列</li>
<li>数据的运算: 运算的定义和实现 (运算的定义针对逻辑结构, 运算的实现针对存储结构)</li>
</ul>
<p>要定义一个数据结构, 就要包括: 数据对象 (是数据的子集 -&gt; 就是数据 -&gt; 包含数据的基本单位“数据元素”)、数据关系 (数据元素之间的关系)、数据运算 (施加在数据上的运算, 是各种基本操作的集合)</p>
<blockquote>
<p>ADT 描述了数据的逻辑结构和数据的运算, 用 (数据对象, 数据关系, 数据运算) 来描述.<br>因此 ADT 可以定义一个完整的数据结构.</p>
</blockquote>
<p>逻辑结构: 包括线性结构和非线性结构. 线性结构就是线性表 (一般线性表, 受限线性表, 数组), 非线性结构就是集合、树、图 (网).</p>
<p>存储结构也称物理结构, 是用计算机语言实现的逻辑结构.</p>
<ul>
<li>顺序: 逻辑上相邻的物理上也相邻. 可以随机存取. 但是只能连续存储, 会产生碎片.</li>
<li>链式: 逻辑上相邻的物理上不一定相邻. 不能随机存取, 只能顺序存取. 要存指针. 但是不会产生碎片.</li>
<li>索引: 用索引表来存储数据元素的地址. 既可以随机存取, 又可以顺序存取. 检索快. 要存索引表. 索引项格式: (关键字, 地址).</li>
<li>散列: Hash. 用散列函数根据元素的关键字直接计算存储地址. 既可以随机存取, 又可以顺序存取. 检索快, 增&#x2F;删快. 散列函数的设计要尽量避免冲突.</li>
</ul>
<p>有序表: 关键字有序的线性表.</p>
<p>链式存储中, 结点间可以不连续, 但结点内一定连续, 因为是数据类型是结构类型 (相当于一个结构体).</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法: 问题求解步骤的描述、指令的有限序列 (每一条指令表示一个或多个操作).</p>
<p>算法的五个特性 (必要条件): 有穷性, 确定性, 可行性, 输入, 输出.</p>
<p>算法的设计要求: 正确性, 可读性, 健壮性, 高效率与低存储量需求.</p>
<p>算法的度量: 时间复杂度 (取决于: 问题的规模、输入数据的性质)、空间复杂度 (包括: 存储程序指令及常&#x2F;变量数据的空间、操作和运算所需的辅助空间).</p>
<p>算法原地工作: 算法所需的辅助空间为常量.</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表: 相同数据类型的数据元素的有限序列.</p>
<p>$$<br>L&#x3D;(a_1, a_2, \cdots, a_n)<br>$$</p>
<p>表头元素: $a_1$, 表尾元素: $a_n$.</p>
<p>性质:</p>
<ul>
<li>除了 $a_1$, 其他元素都有且仅有一个直接前驱; 除了 $a_n$, 其他元素都有且仅有一个直接后继.</li>
<li>有前驱后继关系 -&gt; 表中元素具有逻辑上的顺序性.</li>
<li>数据类型相同: 每个数据元素占有相同大小的存储空间.</li>
</ul>
<blockquote>
<p>线性表是逻辑结构, 邻接表是存储结构. 我认为这个很好区分, 因为邻接表就是一种可以用 C++ 实现出来的数据结构. 而线性表不行, 不能直接用计算机语言实现.</p>
</blockquote>
<p>一些约定俗成的题目中的写法:</p>
<ul>
<li><code>L</code> 表示线性表. 线性表结构体中的 <code>data</code> 表示数据元素数组, <code>length</code> 表示线性表的长度.</li>
<li><code>SqList</code> 表示顺序表的类型结构体, 因此函数参数通常写成 <code>SqList &amp;L</code>.</li>
<li><code>ElemType</code> 表示数据元素.</li>
<li>如果题目说要“显示出错信息并退出运行”, 则函数的返回类型要是 <code>bool</code>.</li>
</ul>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表: 用一段<strong>地址连续</strong>的存储单元依次存储线性表的数据元素 (线性表的<strong>顺序存储</strong>. 结合上一节所说的顺序存储结构, 那就是逻辑顺序和物理顺序相同).</p>
<p>性质:</p>
<ul>
<li>$a_i$ 中的 i 是元素 $a_i$ 在线性表中的位序. 其内存地址: $LOC(L)+(i-1)\cdot sizeof(ElemType)$.</li>
<li>可随机存取. 但插入和删除操作需要移动大量元素, 效率低 (因此不方便).</li>
<li>存储密度高 (因为每个结点只存储数据元素, 不需要存储指针).</li>
</ul>
<blockquote>
<p>线性表中的位序是从 1 开始的, 数组的下标是从 0 开始的.</p>
</blockquote>
<p>静态分配:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

<p>动态分配: 仍然是顺序存储, 只是分配的空间大小可以动态决定.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="type">int</span> MAXSIZE, length;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

<p>动态分配语句:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data = (ElemType *)<span class="built_in">malloc</span>(InitSize * <span class="keyword">sizeof</span>(ElemType));</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data = <span class="keyword">new</span> ElemType[InitSize];</span><br></pre></td></tr></table></figure>

<p>插入: 可插入的位置有 n+1 个. 在第 i 个位置插入, 需要移动 n+1-i 个元素. 平均 O(n).</p>
<p>删除: 可删除的位置有 n 个. 在第 i 个位置删除, 需要移动 n-i 个元素. 平均 O(n).</p>
<p>查找: 顺序查找, 位于第 i 个位置就需要比较 i 次. 平均 O(n).</p>
<h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>链表: <code>LinkList L</code>, <code>L.data</code> 表示数据元素, <code>L.next</code> 表示指针域.</p>
<p>结构体被 <code>typedef</code> 之后, 可以直接用 <code>LNode</code> 来表示结构体类型.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<p><strong>头结点</strong>和<strong>头指针</strong>: 无论有没有头结点, 头指针都一定要有, 并且指向链表中的第一个结点. 在带头结点的链表中, 头指针就指向头结点; 在不带头结点的链表中, 头指针就指向第一个数据结点.</p>
<blockquote>
<p>使用头结点的目的: 方便运算的实现. 因为这样就可以让每个结点的操作得到统一, 不用考虑当前结点是不是第一个数据结点的特殊情况.</p>
</blockquote>
<p>创建带头结点的链表: <code>L = (LinkList)malloc(sizeof(LNode))</code> 创建头结点, <code>L-&gt;next = NULL</code> 初始化为空表.</p>
<p>创建结点: <code>LNode *p = new LNode;</code> 或 <code>LNode *p = (LNode *)malloc(sizeof(LNode));</code></p>
<p>判空:</p>
<ul>
<li>带头结点的链表: <code>L-&gt;next == NULL</code>.</li>
<li>不带头结点的链表: <code>L == NULL</code>.</li>
</ul>
<p>插入:</p>
<ul>
<li>头插法: O(n). 用头指针 L  就可以指示插入位置;</li>
<li>尾插法: O(n). 除了一定要有的头指针 L 外, 还需要一个尾指针指向最后一个结点, 指示插入位置.</li>
</ul>
<p>查找:</p>
<ul>
<li>按序号查找: O(n). 从第一个结点开始, 顺着 <code>next</code> 依次向后查找, 直到找到第 i 个结点为止. 头结点的序号是 0, 第一个数据结点的序号是 1. 因此, 查找第 i 个结点其实是查找第 i 个数据结点, 不包括头结点. 需要比较 i 次 (比较的是 i).</li>
<li>按值查找: O(n). 从第一个结点开始, 顺着 <code>next</code> 依次向后查找, 直到找到第一个值为 e 的结点为止. 最坏需要比较 n 次 (比较的是 <code>p-&gt;data</code>).</li>
</ul>
<p>在第 i 个位置插入元素 e: O(n). 需要找到第 i-1 个结点 (找到待插入位置的前驱结点), 然后插入.</p>
<p>删除第 i 个位置的元素: O(n). 需要找到第 i-1 个结点 (找到待删除位置的前驱结点), 然后释放该结点 (<code>free(q)</code>).</p>
<p>求表长: O(n). 从第一个结点开始, 顺着 <code>next</code> 依次向后查找, 每访问一个节点计数器就加 1, 直到为 <code>NULL</code>. 需要比较 n 次.</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表: <code>DLinkList L</code>, 结构体是 <code>DNode</code>.</p>
<p>有前驱、后继指针.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior, *next;</span><br><span class="line">&#125; DNode, *DLinkList;</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><p>尾指针 <code>*r</code> 的 <code>next</code> 指向头结点.</p>
<p>判空: <code>L == r</code>.</p>
<p>仅设尾指针, 不设头指针. 因为头结点就是尾结点的后继.</p>
<blockquote>
<p>如果设头指针, 则操作表尾需要 O(n); 如果设尾指针, 则操作表头和表尾都只是 O(1).</p>
</blockquote>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p>判空: <code>L-&gt;next == L &amp;&amp; L-&gt;prior == L</code>.</p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>借助数组来描述线性表的链式结构.</p>
<p>链表: <code>SLinkList L</code>, 结构体是 <code>SNode</code>.</p>
<p>数组: <code>SNode L[MAXSIZE]</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SNode, SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>

<p>或者直接:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>

<p><code>next</code> 是游标, 为 -1 时表示无指向.</p>
<p>和顺序表一样, 静态链表也需要预先分配一块连续的存储空间.</p>
<h2 id="线性表的顺序存储结构和链式存储结构的比较"><a href="#线性表的顺序存储结构和链式存储结构的比较" class="headerlink" title="线性表的顺序存储结构和链式存储结构的比较"></a>线性表的顺序存储结构和链式存储结构的比较</h2><ol>
<li>存取方式: 顺序表可以顺序存取、随机存取, 链表只能 (从表头) 顺序存取.</li>
<li>逻辑&#x2F;物理结构: 顺序存储时, 逻辑相邻的物理上也相邻, 要分配连续存储空间; 链式则不需要, 但是结点的存储密度低,多出了指针域.</li>
<li>查找&#x2F;插入&#x2F;删除操作: 按值查找时, 若<strong>顺序表有序</strong>, 则可以二分查找, 时间复杂度为 O(logn), 否则顺序表和链表都是 O(n). 按序号查找时, 顺序表支持随机访问, 仅 O(1). 顺序表的插入和删除需要移动大量元素, 时间复杂度为 O(n), 链表的插入和删除只需要修改指针, 时间复杂度为 O(1).</li>
<li>空间分配: 静态存储分配的顺序表不能扩充, 动态存储分配的顺序表虽能扩充但要移动大量元素. 链表就很灵活, 需要时就可申请.</li>
</ol>
<p>如何选择存储结构:</p>
<ul>
<li>顺序表适合查找多、插入删除少的情况, 否则最好用链表 (对于链表, 虽然在特定位置插入或者删除特定元素也需要从头开始比较和查找, 但是不用移动大量元素!).</li>
<li>难以估计线性表存储规模时, 用链表.</li>
</ul>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>有尾指针的链表在删除某个结点后, 需要判断这个结点是不是尾结点, 如果是, 则需要将尾指针指向新的尾结点.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/01/2022-10-01-ds%E5%A4%8D%E4%B9%A0-part-1/" data-id="clcljm1jz00bf4osb31kh4wt0" data-title="DS复习 Part 1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notes/" rel="tag">notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-09-14-mac配置c-万能头文件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/14/2022-09-14-mac%E9%85%8D%E7%BD%AEc-%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2022-09-14T14:25:05.000Z" itemprop="datePublished">2022-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mac/">Mac</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/14/2022-09-14-mac%E9%85%8D%E7%BD%AEc-%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/">Mac配置C++万能头文件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在<a target="_blank" rel="noopener" href="https://ssc.moe/posts/repeatedly-being-asked-to-install-command-line-tools/">上一篇博客</a>中, 我提到了我是用 <code>sudo xcode-select -switch /Library/Developer/CommandLineTools</code> 解决 g++ 问题的. 但是之前配置的 <code>bits/stdc++.h</code> 头文件不见了. 于是我在这个路径下又配置了一遍.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include</span><br></pre></td></tr></table></figure>

<p>在这个路径下新建 bits 文件夹, 然后在里面新建 <code>stdc++.h</code> 文件, 内容如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ includes used for precompiling -*- C++ -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Copyright (C) 2003-2014 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span></span><br><span class="line"><span class="comment">// software; you can redistribute it and/or modify it under the</span></span><br><span class="line"><span class="comment">// terms of the GNU General Public License as published by the</span></span><br><span class="line"><span class="comment">// Free Software Foundation; either version 3, or (at your option)</span></span><br><span class="line"><span class="comment">// any later version.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">// GNU General Public License for more details.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Under Section 7 of GPL version 3, you are granted additional</span></span><br><span class="line"><span class="comment">// permissions described in the GCC Runtime Library Exception, version</span></span><br><span class="line"><span class="comment">// 3.1, as published by the Free Software Foundation.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You should have received a copy of the GNU General Public License and</span></span><br><span class="line"><span class="comment">// a copy of the GCC Runtime Library Exception along with this program;</span></span><br><span class="line"><span class="comment">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span></span><br><span class="line"><span class="comment">// &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** @file stdc++.h</span></span><br><span class="line"><span class="comment"> *  This is an implementation file for a precompiled header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 17.4.1.2 Headers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GLIBCXX_NO_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfloat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ciso646&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csetjmp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ccomplex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfenv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctgmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cwchar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cwctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;istream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;streambuf&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;valarray&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;scoped_allocator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeindex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>我在网上看到 有人是在 <code>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include</code> 路径下配置的, 可是我的头文件并不在这里.</p>
<p>我的是在 <code>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include</code> 路径下. 从表面上来看, 一个是 Xcode 里的 gcc, 一个是命令行工具里的 gcc.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/14/2022-09-14-mac%E9%85%8D%E7%BD%AEc-%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/" data-id="clcljm1jy00bb4osbfj16762u" data-title="Mac配置C++万能头文件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/solutions/" rel="tag">solutions</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-09-14-repeatedly-being-asked-to-install-command-line-tools" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/14/2022-09-14-repeatedly-being-asked-to-install-command-line-tools/" class="article-date">
  <time class="dt-published" datetime="2022-09-14T12:19:22.000Z" itemprop="datePublished">2022-09-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Mac/">Mac</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/14/2022-09-14-repeatedly-being-asked-to-install-command-line-tools/">Repeatedly Being Asked to Install Command Line Tools</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>After upgrading macOS to 12.6, I was unable to use <code>g++ -v</code>. When I run <code>g++ -v</code> in the command line, it repeatedly asked me to install command line tools. I tried to run <code>xcode-select --install</code>, but the option <code>--install</code> seemed to be wrong.</p>
<p>Later I found that the following command worked:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select -switch /Library/Developer/CommandLineTools</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/14/2022-09-14-repeatedly-being-asked-to-install-command-line-tools/" data-id="clcljm1jy00b74osbe8bmgq4r" data-title="Repeatedly Being Asked to Install Command Line Tools" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/solutions/" rel="tag">solutions</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-09-11-acwing-97-约数之和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/11/2022-09-11-acwing-97-%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/" class="article-date">
  <time class="dt-published" datetime="2022-09-11T13:31:50.000Z" itemprop="datePublished">2022-09-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>►<a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/AcWing/">AcWing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/11/2022-09-11-acwing-97-%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/">AcWing 97 约数之和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/99/">Link</a></p>
<p>先给出关于约数的两个结论:</p>
<p>正整数 n 可以分解质因数为 $\prod_{i&#x3D;1}^k{p_i^{a_i}}&#x3D;p_1^{a_1}\cdot p_2^{a_2}\cdot\dots\cdot p_k^{a_k}$. 则 n 的<strong>正约数个数</strong>就是 $f(n)&#x3D;\prod_{i&#x3D;1}^k{(a_i+1)}$. 因为 $p_i^{a_i}$ 的正约数为 $p_i^0,p_i^1,\dots,p_i^{a_i}$, 共有 $a_i+1$ 个. 根据排列组合的知识, 显然可以看出 n 的<strong>所有正约数之和</strong>为 $\prod_{i&#x3D;1}^k{\sum_{j&#x3D;0}^{a_i}{p_i^j}}&#x3D;(p_1^0+p_1^1+\dots+p_1^{a_1})(p_2^0+p_2^1+\dots+p_2^{a_2})\dots(p_k^0+p_k^1+\dots+p_k^{a_k})$.</p>
<p>有了上面这两个结论, 这题应该就很好做了.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/11/2022-09-11-acwing-97-%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C/" data-id="clcljm1jx00b44osb2qb3c0dk" data-title="AcWing 97 约数之和" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-09-10-acwing-95-费解的开关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/10/2022-09-10-acwing-95-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2022-09-10T03:23:26.000Z" itemprop="datePublished">2022-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>►<a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/AcWing/">AcWing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/10/2022-09-10-acwing-95-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/">AcWing 95 费解的开关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/97/">Link</a></p>
<p>一行有 5 个开关, 对应 32 种按法. 由此联想到用二进制的思想对这 32 种按法进行枚举.</p>
<p>对于每种按法, 首先应用于第一行. 这一点很好理解, 因为无论我们怎么按、从哪里开始, 如果只看第一行的变化, 都可以归结为这 32 种按法中的一种. 而按法并没有顺序要求, 因为是可逆的, 可以还原. 所以任何一种按法都等价于: 先按第一行, 然后再对剩下的行进行调整.</p>
<p>接下来我们调整的方法是, 尽可能地保证当前行的上一行变成全 1. 这是因为, 如果位于 (i,j) 处的元素是 0, 那么想要让它变为 1 并且不改变与它同行的其他元素, 就只能通过翻转它的上面或下面的元素来实现. 但是为了便于编码我们是按照从上到下的顺序进行调整的, 因此: 如果 (i,j) 处的元素是 0, 那么就翻转 (i+1,j) 处的元素.</p>
<p>按照这种做法, 我们能够保证第 0 到 3 行全都变成了 11111, 因此就只需要判断第 4 行中有没有 0. 如果有, 就说明这种按法不行, 否则就更新 ans.</p>
<p>最后就是判断 ans 有没有超过 6, 超过了就按 -1 输出.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">char</span> g[<span class="number">10</span>][<span class="number">10</span>],backup[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rev</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">        <span class="type">int</span> tx=x+dx[i],ty=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(tx&gt;=<span class="number">0</span>&amp;&amp;tx&lt;<span class="number">5</span>&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;ty&lt;<span class="number">5</span>)</span><br><span class="line">            g[tx][ty]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        ans=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line">        <span class="built_in">memcpy</span>(backup,g,<span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">32</span>;++k)&#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;++j)</span><br><span class="line">                <span class="keyword">if</span>((k&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="built_in">Rev</span>(<span class="number">0</span>,j);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;++i)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;++j)</span><br><span class="line">                    <span class="keyword">if</span>(g[i<span class="number">-1</span>][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                        cnt++;</span><br><span class="line">                        <span class="built_in">Rev</span>(i,j);</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;++j)</span><br><span class="line">                <span class="keyword">if</span>(g[<span class="number">4</span>][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">            <span class="built_in">memcpy</span>(g,backup,<span class="built_in">sizeof</span>(g));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;<span class="number">6</span>) ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/10/2022-09-10-acwing-95-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/" data-id="clcljm1jw00b04osbgb8u5e44" data-title="AcWing 95 费解的开关" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2022-09-07-pat-1013-battle-over-cities" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/07/2022-09-07-pat-1013-battle-over-cities/" class="article-date">
  <time class="dt-published" datetime="2022-09-07T10:10:52.000Z" itemprop="datePublished">2022-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>►<a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/PAT/">PAT</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/09/07/2022-09-07-pat-1013-battle-over-cities/">PAT 1013 Battle Over Cities</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/07/2022-09-07-pat-1013-battle-over-cities/" data-id="clcljm1jv00at4osbczf0fgky" data-title="PAT 1013 Battle Over Cities" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Utilities/">Utilities</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/ACM/">ACM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/ACM/%E6%96%87%E7%AB%A0/">文章</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/ACM/%E6%96%87%E7%AB%A0/AcWing/">AcWing</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/AcWing/">AcWing</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/AcWing/%E6%96%87%E7%AB%A0/">文章</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/PAT/">PAT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/%E9%A2%98%E5%8D%95/">题单</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/%E9%A2%98%E5%8D%95/AcWing/">AcWing</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C/">网络</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%AB%A0/">文章</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%8B%B1%E8%AF%AD/">英语</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%8B%B1%E8%AF%AD/TED/">TED</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">计算机体系结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E8%A8%80/C-C/">C/C++</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/01%E8%83%8C%E5%8C%85/" rel="tag">01背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AVL/" rel="tag">AVL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BST/" rel="tag">BST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TSP/" rel="tag">TSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dp/" rel="tag">dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/knapsack/" rel="tag">knapsack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/latex/" rel="tag">latex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notes/" rel="tag">notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/palindrome/" rel="tag">palindrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading/" rel="tag">reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/snippets/" rel="tag">snippets</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solutions/" rel="tag">solutions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tarjan/" rel="tag">tarjan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/trie/" rel="tag">trie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%93%E9%A2%98/" rel="tag">专题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/" rel="tag">个人项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/" rel="tag">分类讨论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/" rel="tag">区间问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" rel="tag">单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E5%BA%8F%E5%88%97/" rel="tag">子序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%8F%E5%85%B3%E7%B3%BB/" rel="tag">序关系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/" rel="tag">数字组合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" rel="tag">最短路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%89%E5%9D%91/" rel="tag">有坑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" rel="tag">树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/" rel="tag">浮点数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" rel="tag">红黑树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" rel="tag">组合数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag">题解</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/01%E8%83%8C%E5%8C%85/" style="font-size: 10px;">01背包</a> <a href="/tags/AVL/" style="font-size: 10.77px;">AVL</a> <a href="/tags/BFS/" style="font-size: 10.77px;">BFS</a> <a href="/tags/BST/" style="font-size: 10px;">BST</a> <a href="/tags/DFS/" style="font-size: 16.15px;">DFS</a> <a href="/tags/Dijkstra/" style="font-size: 11.54px;">Dijkstra</a> <a href="/tags/STL/" style="font-size: 13.08px;">STL</a> <a href="/tags/TSP/" style="font-size: 10.77px;">TSP</a> <a href="/tags/algorithm/" style="font-size: 14.62px;">algorithm</a> <a href="/tags/dp/" style="font-size: 13.08px;">dp</a> <a href="/tags/knapsack/" style="font-size: 10.77px;">knapsack</a> <a href="/tags/latex/" style="font-size: 10px;">latex</a> <a href="/tags/notes/" style="font-size: 19.23px;">notes</a> <a href="/tags/palindrome/" style="font-size: 10px;">palindrome</a> <a href="/tags/reading/" style="font-size: 10px;">reading</a> <a href="/tags/snippets/" style="font-size: 11.54px;">snippets</a> <a href="/tags/solutions/" style="font-size: 10.77px;">solutions</a> <a href="/tags/tarjan/" style="font-size: 10px;">tarjan</a> <a href="/tags/trie/" style="font-size: 10px;">trie</a> <a href="/tags/vscode/" style="font-size: 10px;">vscode</a> <a href="/tags/%E4%B8%93%E9%A2%98/" style="font-size: 13.85px;">专题</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">个人项目</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10.77px;">二分</a> <a href="/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/" style="font-size: 10px;">分类讨论</a> <a href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" style="font-size: 11.54px;">前缀和</a> <a href="/tags/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/" style="font-size: 10px;">区间问题</a> <a href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 10px;">单调栈</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 10px;">哈希</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 16.92px;">图论</a> <a href="/tags/%E5%A0%86/" style="font-size: 11.54px;">堆</a> <a href="/tags/%E5%AD%90%E5%BA%8F%E5%88%97/" style="font-size: 10.77px;">子序列</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 12.31px;">字符串</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 12.31px;">并查集</a> <a href="/tags/%E5%BA%8F%E5%85%B3%E7%B3%BB/" style="font-size: 10px;">序关系</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 12.31px;">排序</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 10.77px;">搜索</a> <a href="/tags/%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/" style="font-size: 10px;">数字组合</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 15.38px;">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 17.69px;">数据结构</a> <a href="/tags/%E6%95%B0%E8%AE%BA/" style="font-size: 11.54px;">数论</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" style="font-size: 13.08px;">最短路径</a> <a href="/tags/%E6%9C%89%E5%9D%91/" style="font-size: 11.54px;">有坑</a> <a href="/tags/%E6%A0%88/" style="font-size: 10.77px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 18.46px;">树</a> <a href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" style="font-size: 10.77px;">树状数组</a> <a href="/tags/%E6%A8%A1%E6%8B%9F/" style="font-size: 11.54px;">模拟</a> <a href="/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/" style="font-size: 11.54px;">浮点数</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 16.92px;">知识点</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" style="font-size: 10px;">红黑树</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" style="font-size: 10px;">组合数学</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 12.31px;">贪心</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 10.77px;">递归</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a> <a href="/tags/%E9%A2%98%E8%A7%A3/" style="font-size: 20px;">题解</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/07/2022-10-07-ds%E5%A4%8D%E4%B9%A0-part-5/">DS复习 Part 5</a>
          </li>
        
          <li>
            <a href="/2022/10/05/2022-10-05-ds%E5%A4%8D%E4%B9%A0-part-4/">DS复习 Part 4</a>
          </li>
        
          <li>
            <a href="/2022/10/04/2022-10-04-ds%E5%A4%8D%E4%B9%A0-part-3/">DS复习 Part 3</a>
          </li>
        
          <li>
            <a href="/2022/10/03/2022-10-03-ds%E5%A4%8D%E4%B9%A0-part-2/">DS复习 Part 2</a>
          </li>
        
          <li>
            <a href="/2022/10/01/2022-10-01-ds%E5%A4%8D%E4%B9%A0-part-1/">DS复习 Part 1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>